---
title: "Computation of finite-sample correction for normal location and scale"
author: "Matthias Kohl"
date: "20 May 2023"
output: html_document
---

# Introduction

From many simulation studies we know that our asymptotic optimally robust 
estimators tend to be too optimistic for finite sample sizes. In this
script we compute a finite-sample correction for normal location and scale 
based on Monte-Carlo simulations. That means, we replace the asymptotic radius
by a finite-sample corrected radius, which is larger or equal to the asymptotic
radius. A larger radius leads to a more conservative estimator.


# Preparations

We load the required functions and data we need for the computations.

```{r}
library(robustbase)
source("../R/rmxNorm.R")
source("../R/rowRmxNorm.R")
load("../R/sysdata.rda")
```

We define the function that we will use for the computations.

```{r}
rowRMX <- function(x, r, k = 3L){
    mean <- robustbase::rowMedians(x, na.rm = TRUE)
    sd <- robustbase::rowMedians(abs(x-mean), na.rm = TRUE)/qnorm(0.75)
    if(r > 10){
        b <- sd*1.618128043
        const <- 1.263094656
        A2 <- b^2*(1+r^2)/(1+const)
        A1 <- const*A2
        a <- -0.6277527697*A2/sd
    }else{
        A1 <- sd^2*.getA1.norm(r)
        A2 <- sd^2*.getA2.norm(r)
        a <- sd*.geta.norm(r)
        b <- sd*.getb.norm(r)
    }
    robEst <- .kstep.norm.matrix(x = x, initial.est = cbind(mean, sd), 
                                 A1 = A1, A2 = A2, a = a, b = b, k = k,
                                 na.rm = TRUE)
    colnames(robEst) <- c("mean", "sd")
    robEst
}
```


# Least favorable contamination

We compute the contaminating distribution that leads to the maximum empirical
finite-sample MSE. 

```{r, eval = FALSE}
n <- 10
M <- 1e6
eps <- 0.01
D <- 0.1
empMSE <- function(r, x, n){
    RadMinmax <- rowRMX(x, r = r)
    n*(mean(RadMinmax[,1]^2) + mean((RadMinmax[,2]-1)^2))
}
r <- rbinom(n*M, prob = eps, size = 1)
Mid <- rnorm(n*M)
Mcont <- rep(D, n*M)
Mre <- matrix((1-r)*Mid + r*Mcont, ncol = n)
ind <- rowSums(matrix(r, ncol = n)) >= n/2
while(any(ind)){
    M1 <- sum(ind)
    cat("M1:\t", M1, "\n")
    r <- rbinom(n*M1, prob = eps, size = 1)
    Mid <- rnorm(n*M1)
    Mcont <- r(contD)(n*M1)
    Mre[ind,] <- (1-r)*Mid + r*Mcont
    ind[ind] <- rowSums(matrix(r, ncol = n)) >= n/2
}
fun1 <- function(D){
    Mcont <- rep(D, n*M)
    Mre <- matrix((1-r)*Mid + r*Mcont, ncol = n)
    empMSE(r = 1, x = Mre, n = n)
}
sapply(c(seq(0.1, 10, length = 20), 20, 50, 100, 1000, 1e4, 1e6), fun1)
```

The simulations show that a Dirac measure at some very high value leads to 
the maximum empirical MSE. We will use it as contaminating distribution in our
subsequent simulations.


# Finite-sample corrected radius

We now compute the finite-sample optimal radius for a grid of sample sizes
and contaminations. The sample size n is at least 3, as it is impossible to 
have less than 50% contamination in case of n = 2.

We define functions to determine the empirical MSE and finite-sample radius.

```{r}
empMSE <- function(r, x, n){
    RadMinmax <- rowRMX(x, r = r)
    n*(mean(RadMinmax[,1]^2) + mean((RadMinmax[,2]-1)^2))
}
finRad <- function(n, eps, D, M){
  r.fi <- numeric(length(eps))
  names(r.fi) <- eps
  i <- 0
  repeat{
    i <- i + 1
    r <- rbinom(n*M, prob = eps[i], size = 1)
    Mid <- rnorm(n*M)
    Mcont <- rep(D, n*M)
    Mre <- matrix((1-r)*Mid + r*Mcont, ncol = n)
    rm(Mid, Mcont)
    gc()
    ind <- rowSums(matrix(r, ncol = n)) >= n/2
    rm(r)
    gc()
    while(any(ind)){
      M1 <- sum(ind)
      r <- rbinom(n*M1, prob = eps[i], size = 1)
      Mid <- rnorm(n*M1)
      Mcont <- rep(D, n*M1)
      Mre[ind,] <- (1-r)*Mid + r*Mcont
      ind[ind] <- rowSums(matrix(r, ncol = n)) >= n/2
      rm(Mid, Mcont, r)
      gc()
    }
    r.fi[i] <- optimize(empMSE, 
                        interval = c(eps[i], min(max(2, n*eps[i]*25), 10)), 
                        x = Mre, n = n)$minimum
    rm(Mre)
    gc()
    if(round(r.fi[i], 2) == 1.74 | i == length(eps)) break
  }
  r.fi
}
```

To speed up the computations, we use packages foreach and doParallel.

```{r}
library(foreach)
library(doParallel)
M <- 1e6
D <- 1e6
n <- c(3:50, seq(55, 100, by = 5), seq(110, 200, by = 10), seq(225, 500, by = 25))
eps <- c(seq(0.001, 0.05, by = 0.001), seq(0.06, to = 0.5, by = 0.01))
cores <- detectCores()
cl <- makeCluster(cores[1]-3)
registerDoParallel(cl)
```

We compute the finite-sample radii.

```{r}
system.time(r.fi1 <- foreach(i=seq(along = n[1:30])) %dopar% {
  finRad(n[i], eps, D, M)
})
r.fi1 <- do.call("cbind", r.fi1)
save(r.fi1, file = "FiniteSampleRadiusNorm_M1e6_1.RData")
system.time(r.fi2 <- foreach(i=seq(along = n[31:50])) %dopar% {
  finRad(n[30+i], eps, D, M)
})
r.fi2 <- do.call("cbind", r.fi2)
save(r.fi2, file = "FiniteSampleRadiusNorm_M1e6_2.RData")
system.time(r.fi3 <- foreach(i=seq(along = n[51:68])) %dopar% {
  finRad(n[50+i], eps, D, M)
})
r.fi3 <- do.call("cbind", r.fi3)
save(r.fi3, file = "FiniteSampleRadiusNorm_M1e6_3.RData")

system.time(r.fi4 <- foreach(i=seq(along = n[69:75])) %dopar% {
  finRad(n[68+i], eps, D, M)
})
r.fi4 <- do.call("cbind", r.fi4)
save(r.fi4, file = "FiniteSampleRadiusNorm_M1e6_4.RData")
system.time(r.fi5 <- foreach(i=seq(along = n[76:80])) %dopar% {
  finRad(n[75+i], eps, D, M)
})
r.fi5 <- do.call("cbind", r.fi5)
save(r.fi5, file = "FiniteSampleRadiusNorm_M1e6_5.RData")
r.fi <- cbind(r.fi1, r.fi2, r.fi3, r.fi4, r.fi5)
colnames(r.fi) <- n
save(r.fi, file = "FiniteSampleRadiusNorm_M1e6.RData")
```

```{r}
for(i in n){
  if(as.character(i) %in% colnames(r.fi) && 
     as.character(i) %in% colnames(.fsRadius.norm)){
    ind1 <- which(as.character(i) == colnames(r.fi))
    ind2 <- which(as.character(i) == colnames(.fsRadius.norm))
    plot(eps, r.fi[,ind1], type = "b", main = paste0("n = ", i))
    lines(as.numeric(rownames(.fsRadius.norm)), .fsRadius.norm[,ind2], 
          col = "darkred", type = "b")
  }
}
```



```{r}
r.fi[r.fi > 2] <- NA
r.fi[16,9] <- mean(r.fi[c(15,17),9])
r.fi[14:15,11] <- approx(eps[c(13,16)], r.fi[c(13,16),11], xout = c(0.014, 0.015))$y
r.fi[13,12] <- r.fi[12,12] + diff(r.fi[c(12,15),12])/3
r.fi[14,12] <- r.fi[13,12] + diff(r.fi[c(12,15),12])/3
r.fi[12:14,13] <- approx(eps[c(11,15)], r.fi[c(11,15),13], xout = c(0.012, 0.013, 0.014))$y
r.fi[11:13,14] <- approx(eps[c(10,14)], r.fi[c(10,14),14], xout = c(0.011, 0.012, 0.013))$y
r.fi[11:13,15] <- approx(eps[c(10,14)], r.fi[c(10,14),15], xout = c(0.011, 0.012, 0.013))$y
r.fi[10:13,16] <- approx(eps[c(9,14)], r.fi[c(9,14),16], xout = c(0.010, 0.011, 0.012, 0.013))$y
r.fi[10:13,17] <- approx(eps[c(9,14)], r.fi[c(9,14),17], xout = c(0.010, 0.011, 0.012, 0.013))$y
r.fi[9:12,18] <- approx(eps[c(8,13)], r.fi[c(8,13),18], xout = c(0.009, 0.010, 0.011, 0.012))$y
r.fi[9:12,19] <- approx(eps[c(8,13)], r.fi[c(8,13),19], xout = c(0.009, 0.010, 0.011, 0.012))$y
r.fi[8:11,20] <- approx(eps[c(7,12)], r.fi[c(7,12),20], xout = c(0.008, 0.009, 0.010, 0.011))$y
r.fi[8:11,21] <- approx(eps[c(7,12)], r.fi[c(7,12),21], xout = c(0.008, 0.009, 0.010, 0.011))$y
r.fi[8:11,22] <- approx(eps[c(7,12)], r.fi[c(7,12),22], xout = c(0.008, 0.009, 0.010, 0.011))$y
r.fi[7:11,23] <- approx(eps[c(6,12)], r.fi[c(6,12),23], xout = c(0.007, 0.008, 0.009, 0.010, 0.011))$y
r.fi[7:10,24] <- approx(eps[c(6,11)], r.fi[c(6,11),24], xout = c(0.007, 0.008, 0.009, 0.010))$y
r.fi[7:10,25] <- approx(eps[c(6,11)], r.fi[c(6,11),25], xout = c(0.007, 0.008, 0.009, 0.010))$y
r.fi[7:10,26] <- approx(eps[c(6,11)], r.fi[c(6,11),26], xout = c(0.007, 0.008, 0.009, 0.010))$y
r.fi[6:10,27] <- approx(eps[c(5,11)], r.fi[c(5,11),27], xout = c(0.006, 0.007, 0.008, 0.009, 0.010))$y
r.fi[6:9,28] <- approx(eps[c(5,10)], r.fi[c(5,10),28], xout = c(0.006, 0.007, 0.008, 0.009))$y
r.fi[6:9,29] <- approx(eps[c(5,10)], r.fi[c(5,10),29], xout = c(0.006, 0.007, 0.008, 0.009))$y
r.fi[6:9,30] <- approx(eps[c(5,10)], r.fi[c(5,10),30], xout = c(0.006, 0.007, 0.008, 0.009))$y
r.fi[6:9,31] <- approx(eps[c(5,10)], r.fi[c(5,10),31], xout = c(0.006, 0.007, 0.008, 0.009))$y
r.fi[6:9,32] <- approx(eps[c(5,10)], r.fi[c(5,10),32], xout = c(0.006, 0.007, 0.008, 0.009))$y
r.fi[5:8,33] <- approx(eps[c(4,9)], r.fi[c(4,9),33], xout = c(0.005, 0.006, 0.007, 0.008))$y
r.fi[5:8,34] <- approx(eps[c(4,9)], r.fi[c(4,9),34], xout = c(0.005, 0.006, 0.007, 0.008))$y
r.fi[5:8,35] <- approx(eps[c(4,9)], r.fi[c(4,9),35], xout = c(0.005, 0.006, 0.007, 0.008))$y
r.fi[5:8,36] <- approx(eps[c(4,9)], r.fi[c(4,9),36], xout = c(0.005, 0.006, 0.007, 0.008))$y
r.fi[5:8,37] <- approx(eps[c(4,9)], r.fi[c(4,9),37], xout = c(0.005, 0.006, 0.007, 0.008))$y
r.fi[5:7,38] <- approx(eps[c(4,8)], r.fi[c(4,8),38], xout = c(0.005, 0.006, 0.007))$y
r.fi[5:7,39] <- approx(eps[c(4,8)], r.fi[c(4,8),39], xout = c(0.005, 0.006, 0.007))$y
r.fi[5:7,40] <- approx(eps[c(4,8)], r.fi[c(4,8),40], xout = c(0.005, 0.006, 0.007))$y
r.fi[5:7,41] <- approx(eps[c(4,8)], r.fi[c(4,8),41], xout = c(0.005, 0.006, 0.007))$y
r.fi[4:7,42] <- approx(eps[c(3,8)], r.fi[c(3,8),42], xout = c(0.004, 0.005, 0.006, 0.007))$y
r.fi[4:7,43] <- approx(eps[c(3,8)], r.fi[c(3,8),43], xout = c(0.004, 0.005, 0.006, 0.007))$y
r.fi[4:7,44] <- approx(eps[c(3,8)], r.fi[c(3,8),44], xout = c(0.004, 0.005, 0.006, 0.007))$y
r.fi[4:7,45] <- approx(eps[c(3,8)], r.fi[c(3,8),45], xout = c(0.004, 0.005, 0.006, 0.007))$y
r.fi[4:6,46] <- approx(eps[c(3,7)], r.fi[c(3,7),46], xout = c(0.004, 0.005, 0.006))$y
r.fi[4:6,47] <- approx(eps[c(3,7)], r.fi[c(3,7),47], xout = c(0.004, 0.005, 0.006))$y
r.fi[4:6,48] <- approx(eps[c(3,7)], r.fi[c(3,7),48], xout = c(0.004, 0.005, 0.006))$y
r.fi[4:6,49] <- approx(eps[c(3,7)], r.fi[c(3,7),49], xout = c(0.004, 0.005, 0.006))$y
r.fi[3:5,50] <- approx(eps[c(2,6)], r.fi[c(2,6),50], xout = c(0.003, 0.004, 0.005))$y
r.fi[3:5,51] <- approx(eps[c(2,6)], r.fi[c(2,6),51], xout = c(0.003, 0.004, 0.005))$y
r.fi[3:4,52] <- approx(eps[c(2,5)], r.fi[c(2,5),52], xout = c(0.003, 0.004))$y
r.fi[3:4,53] <- approx(eps[c(2,5)], r.fi[c(2,5),53], xout = c(0.003, 0.004))$y
r.fi[3:4,54] <- approx(eps[c(2,5)], r.fi[c(2,5),54], xout = c(0.003, 0.004))$y
r.fi[3:4,55] <- approx(eps[c(2,5)], r.fi[c(2,5),55], xout = c(0.003, 0.004))$y
r.fi[2:4,56] <- approx(eps[c(1,5)], r.fi[c(1,5),56], xout = c(0.002, 0.003, 0.004))$y
r.fi[2:3,57] <- approx(eps[c(1,4)], r.fi[c(1,4),57], xout = c(0.002, 0.003))$y
r.fi[2:3,58] <- approx(eps[c(1,4)], r.fi[c(1,4),58], xout = c(0.002, 0.003))$y
r.fi[2:3,59] <- approx(eps[c(1,4)], r.fi[c(1,4),59], xout = c(0.002, 0.003))$y
r.fi[2:3,60] <- approx(eps[c(1,4)], r.fi[c(1,4),60], xout = c(0.002, 0.003))$y
r.fi[2,61] <- mean(r.fi[c(1,3),61])
r.fi[2,62] <- mean(r.fi[c(1,3),62])
r.fi[2,63] <- mean(r.fi[c(1,3),63])
r.fi[2,64] <- mean(r.fi[c(1,3),64])
r.fi[2,65] <- mean(r.fi[c(1,3),65])
r.fi[1,66:74] <- approx(n[c(65,75)], r.fi[1,c(65,75)], xout = c(180, 190, 200, 225, 250, 275, 300, 325, 350))$y
r.fi[2,66] <- mean(r.fi[c(1,3),66])
save(r.fi, file = "FiniteSampleRadiusNorm_M1e6_korr.RData")
```


We take a look at the results.

```{r}
r.as <- outer(eps, sqrt(n))
## no convergence resp. wrong optima
sum(r.fi > 1.744, na.rm = TRUE)
r.fi[r.fi > 1.744 & !is.na(r.fi)]
```

```{r}
r.finit <- r.fi
r.finit[r.finit > 1.67] <- 1.67
r.finit[r.finit == 0] <- 1.67
for(i in n){
  if(as.character(i) %in% colnames(r.fi) && 
     as.character(i) %in% colnames(.fsRadius.norm)){
    ind1 <- which(as.character(i) == colnames(r.fi))
    ind2 <- which(as.character(i) == colnames(.fsRadius.norm))
    plot(eps, r.finit[,ind1], type = "b", main = paste0("n = ", i))
    lines(as.numeric(rownames(.fsRadius.norm)), .fsRadius.norm[,ind2], 
          col = "darkred", type = "b")
  }
}
save(r.finit, file = "FiniteSampleRadiusNorm_M1e6_final.RData")
load("../R/sysdata.rda")
.fsRadius.norm <- r.finit
save(.fsRadius.norm, .radius.gitter.norm, .A1.norm, .A2.norm, 
     .a.norm, .b.norm, .asVar.mean.norm, .asVar.sd.norm, 
     file = "sysdata.rda")
```


```{r}
M <- 1e2
D <- 1e6
n <- c(3:50, seq(55, 100, by = 5), seq(110, 200, by = 10), seq(250, 500, by = 25))
eps <- c(seq(0.001, 0.05, by = 0.001), seq(0.06, to = 0.5, by = 0.01))
empVarBias <- function(n, eps, D, M){
  empBias <- empVar <- numeric(length(eps))
  names(empBias) <- names(empVar) <- eps
  for(i in 1:length(eps)){
    r <- rbinom(n*M, prob = eps[i], size = 1)
    Mid <- rnorm(n*M)
    Mcont <- rep(D, n*M)
    Mre <- matrix((1-r)*Mid + r*Mcont, ncol = n)
    rm(Mid, Mcont)
    gc()
    ind <- rowSums(matrix(r, ncol = n)) >= n/2
    rm(r)
    gc()
    while(any(ind)){
      M1 <- sum(ind)
      r <- rbinom(n*M1, prob = eps[i], size = 1)
      Mid <- rnorm(n*M1)
      Mcont <- rep(D, n*M1)
      Mre[ind,] <- (1-r)*Mid + r*Mcont
      ind[ind] <- rowSums(matrix(r, ncol = n)) >= n/2
      rm(Mid, Mcont, r)
      gc()
    }
    RadMinmax <- rowRMX(x, r = eps/sqrt(n))
    empBias[i] <- n*c(mean(RadMinmax[,1]), mean(RadMinmax[,2]-1))
    empRisk[i] <- n*c(mean(RadMinmax[,1]), mean(RadMinmax[,2]-1))
    rm(Mre)
    gc()
  }
  cbind(empBias, empVar)
}
```

